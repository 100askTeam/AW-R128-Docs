import{_ as e,o as d,c as t,e as a}from"./app-e85d5a28.js";const n={},s=a(`<h1 id="rtos-存储简介" tabindex="-1"><a class="header-anchor" href="#rtos-存储简介" aria-hidden="true">#</a> RTOS 存储简介</h1><p>FreeRTOS 设计的完整的 IO 栈包括 <strong>iobox、vfs、fs、blkpart、flash driver</strong>。考虑到 RTOS 比 Linux 更精小高效和 Flash 不需要考虑寻址的特点，并没参考 Linux 设计 Page Cache 和 IO调度器，但在 Flash driver 添加了 Cache 以加速性能。</p><p>常见的系统中，都会为 Flash 设备专门设计 MTD 层，起到对 flash driver 进一步封装。在 RTOS 的 IO 栈中，blkpart 就实现了MTD层的功能，除此之外，还实现了分区解析和操作。为了兼容和符合规范，在将来的迭代中可以考虑把 blkpart 拆分出 MTD 层。</p><h2 id="iobox简介" tabindex="-1"><a class="header-anchor" href="#iobox简介" aria-hidden="true">#</a> iobox简介</h2><p>iobox 是在 RTOS 实现的一套简单的 IO 命令的集合。其在 <code>menuconfig</code> 中的路径为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>System components
    |-&gt; aw components
        |-&gt; iobox
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>目前支持以下命令：</p><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>ls</code></td><td>列出文件</td><td><code>ls /data</code></td></tr><tr><td><code>ll</code></td><td>等效于ls -lk</td><td><code>ll /data</code></td></tr><tr><td><code>cat</code></td><td>读取并打印文件</td><td><code>cat /data/demo</code></td></tr><tr><td><code>hexdump</code></td><td>十六进制显示文件内容</td><td><code>hexdump /data/demo</code></td></tr><tr><td><code>hd</code></td><td>等效于hexdump -C</td><td><code>hd /data/demo</code></td></tr><tr><td><code>cp</code></td><td>复制文件</td><td><code>cp /data/demo /data/demo1</code></td></tr><tr><td><code>mv</code></td><td>重命名文件</td><td><code>mv /data/demo /data/demo1</code></td></tr><tr><td><code>rm</code></td><td>删除文件</td><td><code>rm /data/demo</code></td></tr><tr><td><code>unlink</code></td><td>取消硬链接(等效于删除文件)</td><td><code>unlink /data/demo</code></td></tr><tr><td><code>link</code></td><td>创建硬链接</td><td><code>link /data/demo</code></td></tr><tr><td><code>rwcheck</code></td><td>读写测试</td><td><code>rwcheck -d /data -s 256k -s 1000000</code></td></tr><tr><td><code>rwspeed</code></td><td>顺序读写性能测试</td><td><code>rwspeed -d /data -s 128k -t 3</code></td></tr><tr><td><code>vi</code></td><td>vi文本编辑器</td><td><code>vi /data/demo</code></td></tr><tr><td><code>df</code></td><td>显示fs信息</td><td><code>df /data</code></td></tr></tbody></table><blockquote><p>-h参数可以获取详细的使用说明</p></blockquote><h2 id="vfs简介" tabindex="-1"><a class="header-anchor" href="#vfs简介" aria-hidden="true">#</a> VFS简介</h2><p>VFS 类似与 Linux VFS，是为所有的 FS 提供统一的标准，向上注册和提供系统调用。正因为有 VFS 的存在，用户才可以忽略文件系统的差异，只需要调用规范的 IO 函数即可实现 IO 操作，例如 <code>read()</code>，<code>ioctl()</code>，<code>rename()</code>。</p><p>RTOS 的 VFS 移植自第三方的开源 VFS，在 <code>menuconfig</code> 的选择路径为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>System components
    |-&gt; thirdparty components
        |-&gt; Virtual Filesystem
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="fs简介" tabindex="-1"><a class="header-anchor" href="#fs简介" aria-hidden="true">#</a> FS简介</h2><h3 id="spiffs-和-littlefs" tabindex="-1"><a class="header-anchor" href="#spiffs-和-littlefs" aria-hidden="true">#</a> spiffs 和 littlefs</h3><p>当前，RTOS 支持 spiffs 和 littlefs 两种文件系统</p><p>总的来说，<strong>推荐使用littlefs</strong>。</p><p><code>spiffs</code> 在 <code>menuconfig</code> 的路径为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>System components
    |-&gt; thirdparty components
        |-&gt; SPIFFS Filesystem
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>littlefs</code> 在 <code>menuconfig</code> 的路径为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>System components
    |-&gt; thirdparty components
        |-&gt; LittleFS Filesystem
            |-&gt; LFS Codes Version (v2.2.1)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>RTOS 中暂不支持 Linux 上常见的 flash 文件系统，例如 yaffs，jffs2，主要是因为 开源协议 和 体量臃肿 的考虑。</p><p>与 Linux 相似，文件系统需要使用必须先挂载。littlefs 和 spiffs提供的挂载/卸载接口如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;spiffs.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">spiffs_mount</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>source<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>target<span class="token punctuation">,</span> bool format<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">spiffs_umount</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">incldue</span> <span class="token expression"><span class="token operator">&lt;</span>littlefs<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>
<span class="token keyword">int</span> <span class="token function">littlefs_mount</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>mnt<span class="token punctuation">,</span> bool format<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">littlefs_umount</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>mnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="打包fs资源文件" tabindex="-1"><a class="header-anchor" href="#打包fs资源文件" aria-hidden="true">#</a> 打包FS资源文件</h3><p>在项目中，如果需要在编译时创建基于文件系统的资源镜像包，在烧录的时候直接写入分区，可以使用以下方法：</p><ol><li>修改分区文件，添加 <code>downloadfile</code> 配置</li><li>在资源目录创建与分区名同名的文件夹，并把资源文件放入此文件夹</li></ol><p>由于 RTOS 系统默认使用 littlefs，因此创建的资源文件包也是基于 littlefs 。</p><p>例如，需要在UDISK分区创建资源包，可以这么改：</p><p>第一步，在 <code>sys_partition{_NOR}.fex</code> 中，在 <code>UDISK</code> 分区项中修改 <code>downloadfile</code> 配置为 <code>data_</code> 开头的文件：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[partition]
     name         = UDISK
     downloadfile = &quot;data_udisk.fex&quot;
     user_type    = 0x8100
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意，如果使能了 <code>CONFIG_XIP</code>，则该配置文件名称为<code>sys_partition_xip_{_NOR}.fex</code>。</p><p>资源文件名必须以data_开头，这是触发脚本打包资源文件的标识。其余的名字不限制。</p><p>第二步，在<code>tina-rt/tools/data</code>中创建与<strong>分区名</strong>相同名字的文件夹，例如</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ mkdir -p board/&lt;chip_name&gt;/&lt;project_name&gt;/data/UDISK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>并把资源文件拷贝进去即可。</p><h3 id="devfs" tabindex="-1"><a class="header-anchor" href="#devfs" aria-hidden="true">#</a> devfs</h3><p>在 RTOS 里，有实现 devfs 的设备文件系统。正因为 <code>devfs</code> 的存在，在 <code>/dev</code> 目录下，就可以看到设备文件。</p><p>OTA更新可以直接操作设备节点，以实现分区级别的更新。</p><p>由于历史原因，驱动可能在 <code>/dev</code> 下注册了 设备节点和分区名节点，也可能在 <code>/dev</code> 下注册了设备节点，在 <code>/dev/by-name</code> 下注册别名节点。例如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>/dev/UDISK
/dev/by-name/UDISK
/dev/nand0p5
/dev/NOR
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>开发者可以通过 <code>ls /dev</code> 命令确认驱动把设备注册在哪里。</p><h2 id="文件操作方式" tabindex="-1"><a class="header-anchor" href="#文件操作方式" aria-hidden="true">#</a> 文件操作方式</h2><h3 id="普通文件读写接口" tabindex="-1"><a class="header-anchor" href="#普通文件读写接口" aria-hidden="true">#</a> 普通文件读写接口</h3><p>可以使用标准的 Posix 操作接口，如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ssize_t read (int __fd, void *__buf, size_t __nbytes);
ssize_t write (int __fd, const void *__buf, size_t __n);
int close (int __fd);
int open (char *name, int flag);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以使用 C 库的文件操作接口，如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>size_t fread (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
size_t fwrite (const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __s);
FILE *fopen (const char *__restrict __filename, const char *__restrict __modes);
int fclose (FILE *__stream);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="设备分区文件操作" tabindex="-1"><a class="header-anchor" href="#设备分区文件操作" aria-hidden="true">#</a> 设备分区文件操作</h3><p>存储分区设备节点可以被当前一个普通文件来读写，如以下例子：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 该例子可用于读取 env 分区中的内容
char buffer[32];
int fd = open(&quot;/dev/env&quot;, O_RDONLY);
read(fd, buffer, sizeof(buffer));
close(fd);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="blkpart简介" tabindex="-1"><a class="header-anchor" href="#blkpart简介" aria-hidden="true">#</a> blkpart简介</h2><p>如上所属，RTOS 设计的 blkpart 类似与 MTD，起到对 flash driver 进一步封装的功能，此外还实现了分区解析和分区操作。</p><p>blkpart与MTD设计的出发点有些不同，blkpart如其名，主要是把存储空间按块设备分区的逻辑管理，而MTD更多只是规范flash驱动的注册和使用方法。期待将来的迭代中能对blkpart进一步规范，拆离出MTD层，让开发者更好理解。</p><p>blkpart在 <code>menuconfig</code> 的路径为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>System components
    |-&gt; aw components
        |-&gt; Block Partition
            |-&gt; Partition Table Size (KB) # 配置GPT分区表的存储空间大小
            |-&gt; Logical Partition Start Address (KB) # 分区表起作用的开始偏移
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>驱动通过调用以下接口注册和注销设备：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>int add_blkpart(struct blkpart *blk);
void del_blkpart(struct blkpart *blk);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注册设备后，blkpart会自行解析分区，并向上注册。上层可以通过以下接口访问设备：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ssize_t blkpart_read(struct part *, uint32_t, uint32_t, void *);
ssize_t blkpart_write(struct part *, uint32_t, uint32_t, const void *);
int blkpart_erase(struct part *, uint32_t, uint32_t);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这几个接口就类似于MTD中的 <code>mtd_read/mtd_write/mtd_erase</code>。</p><h2 id="flash-驱动" tabindex="-1"><a class="header-anchor" href="#flash-驱动" aria-hidden="true">#</a> Flash 驱动</h2><p>RTOS 主要支持 SPINOR 和 SPINAND 两类存储介质。</p><h3 id="spi-nor" tabindex="-1"><a class="header-anchor" href="#spi-nor" aria-hidden="true">#</a> SPI NOR</h3><p>NOR 驱动相对简单，只是按照协议通过 spi 发送操作指令。其中为了加快性能，在 NOR 驱动上添加了简单的Cache层。部分 Flash 物料在测试过程中发现了一些掉电场景下会掉码问题，因此若该物料支持写保护功能，则可以使能写保护来避免掉电场景下出现掉码问题。</p><h4 id="cache" tabindex="-1"><a class="header-anchor" href="#cache" aria-hidden="true">#</a> Cache</h4><p>Cache 层的代码，是为了尽可能合并连续写入的数据，再一次性写入。</p><p>NOR 写之前必须先擦除，普遍支持 <code>Sector Erase</code>，<code>32KB Block Erase</code> ，<code>64KB Block Erase</code> 和 <code>Chip Erase</code>的四种擦除方式。查看 NOR 的规格书发现，除了擦除大小不一致外，擦除性能也有很大差别：</p><table><thead><tr><th>厂家</th><th>写(ms)</th><th>4K擦除(ms)</th><th>32K擦除(ms)</th><th>64K擦除(ms)</th><th>全盘擦除(s)</th></tr></thead><tbody><tr><td>MXIC</td><td>0.33~1.2</td><td>25~120</td><td>140~650</td><td>250~650</td><td>26~60</td></tr><tr><td>Winbond</td><td>0.7~3</td><td>45~400</td><td>120~1600</td><td>150~2000</td><td>40~200</td></tr><tr><td>GD</td><td>0.5~2.4</td><td>50~400</td><td>160~800</td><td>300~1200</td><td>50~120</td></tr><tr><td>ESMT</td><td>0.5~3</td><td>40~300</td><td>200~1000</td><td>300~2000</td><td>60~200</td></tr></tbody></table><p>总的来说，擦除性能 <code>Chip Erase &gt; 64KB Block Erase &gt; 32KB Block Erase &gt; Sector Erase</code>。而一次写操作的耗时主要是擦除，因此，如果需要优化写性能，需要尽可能使用更大的擦除。</p><p>考虑到文件系统的空间浪费情况，文件系统需要采用 4K 的块大小，进一步导致驱动必须 <code>Sector Erase</code>, 也就是4K擦除。这样的矛盾导致 NOR 的写性能偏低。</p><p>因此，创建了 64K Block 大小的 Cache, 每一次文件系统的写和擦除操作都缓存起来，在合适时机一次写擦除和写入。为了防止 Cache 的存在导致文件系统丢数据，合适时机的选择非常重要。</p><p>在实现中充分考虑的 littlefs 的机制，在以下时机写入保证了不会丢失数据：</p><ol><li>FS主动调用 sync 要求回刷数据时</li><li>Cache缓存的数据满足64K Block或者32K Block了</li><li>FS 写入的地址跨了另外一个Block</li></ol><p>其他文件系统的支持，需要结合文件系统的实现，以评估是否会丢失数据。</p><h4 id="写保护" tabindex="-1"><a class="header-anchor" href="#写保护" aria-hidden="true">#</a> 写保护</h4><p>在测试中发现，掉电时如果主控依然在发送数据，NOR很大概率会造成误写，把数据写入其他地址，导致数据被损坏。为了解决这个问题，除了硬件实现掉电时马上复位的方法外，软件上也可以使能写保护，让NOR在误写时无法写入。</p><p>目前发现的写保护机制有两种，一个是区间保护，一个是独立块保护，两者的差别主要是保护和解保护的最小颗粒不同。</p><p>区间保护(Status Register Memory Protection, 或描述为bp写保护，Block Protect，Block Lock protection mode，protect area等)按从低或高地址开始的一段连续空间保护。以 16M 容量的NOR为例，配置为从低地址开始的8M空间，可实现0-8M的空间无法写入，但无法保护 8-16M 的空间。不同厂家划分的保护区间可能有稍许不同，但都无法做到精细保护。例如如果需要写第7M地址的数据，此时只能把保护范围缩减为 0-4M，使得 4-16M 可写，此时依然会有大概率会误写数据。</p><p>独立块保护(Individual Block Memory Protect，或描述为Individual Sector Protection mode等)是以块为单位单独控制是否保护。一般而言，块大小是64K，即一次可以做到只解保护64K的小范围。</p><p>从理论分析，独立块保护的掉电误写风险远比区间保护小。</p><p>启用写保护功能，还需要考虑频繁保护与解保护会带来多大的性能损失和寿命损失。</p><p>区间保护修改的状态寄存器跟NOR一样，只有10W次的擦写寿命，且写入时间在ms级别。如果使用区间保护，频繁的修改保护区间，会导致性能下降，且会加速状态寄存器的磨损。</p><p>独立块保护修改的是SRAM状态位，无明显擦写寿命限制，且写入时间在ns级别，即使频繁修改保护状态，对性能影响非常微弱。</p><p>因此，如果NOR支持，推荐使用独立块保护。区间保护更适用于不需要频繁解保护的场景。</p><p>总的来说，</p><ul><li>如果NOR支持独立块保护，则采用独立块保护，再根据预算决定是否采用硬件复位。</li><li>如果NOR不支持独立块保护，建议采用硬件复位，取消软件写保护以提高性能和减少磨损。</li></ul><h4 id="新物料的支持和测试" tabindex="-1"><a class="header-anchor" href="#新物料的支持和测试" aria-hidden="true">#</a> 新物料的支持和测试</h4><p>因为写保护的存在，导致新物料适配更加复杂。</p><p><code>uboot</code>: 烧录所用的 <code>uboot</code> 需要适配解锁操作。主要是在 <code>drivers/mtd/spi/spi-NOR-ids.c</code> 中给对应物料配置上 <code>SPI_NOR_HAS_LOCK</code>(支持写保护) 和 <code>SPI_NOR_INDIVIDUAL_LOCK</code>(块保护) 等标志，并实现对应的锁操作函数。</p><p><code>rtos</code>: 添加新物料的支持，主要是添加 <code>struct NOR_info NOR_ids[]</code>：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>struct NOR_info {
    char *name;
    unsigned char id[MAX_ID_LEN];
    unsigned int blk_size;
    unsigned int blk_cnt;

    struct NOR_protection *pt;
    unsigned int pt_len;
    unsigned int pt_def;

    int flag;
 #define EN_IO_PROG_X4 BIT(1)
 #define EN_IO_READ_X2 BIT(2)
 #define EN_IO_READ_X4 BIT(3)
 #define EN_INDIVIDUAL_PROTECT_MODE BIT(4)
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不考虑写保护，只需要把前4项根据 SPEC 信息填写即可。其中blk_size对应文件系统的块大小，因此建议设置为4096，因此 <code>blk_cnt</code> 就是NOR总大小除以4096。</p><p>pt，pt_len和pt_def适用于区间保护。由于不再推荐使用区间保护，因此不展开介绍。</p><p>flag通过设置 <code>EN_INDIVIDUAL_PROTECT_MODE BIT</code> 以支持独立块保护。</p><p><strong>在新物料适配后，需要进行大量压测，以确保足够稳定</strong></p><h3 id="spi-nand" tabindex="-1"><a class="header-anchor" href="#spi-nand" aria-hidden="true">#</a> SPI NAND</h3><p>SPINAND的物理特性比 SPINOR 复杂，对驱动要求更高。RTOS 通过适配全志自研的NFTL，实现在 RTOS 上支持SPINAND。</p><p>NFTL实现只提供静态库，结合已经开源的物理层代码，即可在 RTOS 上支持SPINAND。</p><h2 id="emmc-sd-card-sd-nand-驱动" tabindex="-1"><a class="header-anchor" href="#emmc-sd-card-sd-nand-驱动" aria-hidden="true">#</a> eMMC / SD Card / SD Nand 驱动</h2><p>eMMC / SD Card / SD Nand 使用的是标准的 SDIO 接口，BROM 支持从支持的 MMC 储存器启动。支持 TF 卡启动，eMMC 启动，SD Nand 启动，也支持通过 SDIO 读取相关存储设备的数据。</p>`,101),i=[s];function c(r,o){return d(),t("div",null,i)}const p=e(n,[["render",c],["__file","chapter12.html.vue"]]);export{p as default};
